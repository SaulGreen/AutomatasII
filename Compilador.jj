PARSER_BEGIN(Compilador)
	import java.io.*;
	import java.util.*;
	
	public class Compilador
	{
		public static void main(String[] args )throws ParseException
		{
			BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
			String filepath;
			Compilador parser;
			
			System.out.print("Direccion del archivo");
			try
			{
				filepath = reader.readLine();
			}
			catch(IOException e)
			{
				System.out.println("Direccion Erronea, verifique");
				return;
			}
			try
			{
				parser = new Compilador(new FileInputStream(filepath));
			}
			catch(FileNotFoundException e)
			{
				System.out.println("El archivo no existe");
				return;
			}
			try
			{
				parser.mInicioPrograma();				
				System.out.println("Analisis finalizó sin errores");
				
			}
			catch (ParseException e)
			{
				System.out.println(e.getMessage());
				System.out.println("Analisis de finalizó con errores");
			}
		}
	}
PARSER_END(Compilador)

TOKEN : 
{ 
	  <ASIGNACION: "=">  
	| <PLUS: "+" >  
	| <MINUS:"-"> 
	| <MULTIPLY:"*"> 
	| <DIVIDE:"/"> 
	| <INCR: "++" > 
	| <DECR: "--" > //7	
}

TOKEN:
{
	  <PUBLIC: "public"> 
	| <PRIVATE: "private"> 
	| <STATIC: "static"> 
	| <VOID: "void"> 
	| <MAIN: "public static void Main()"> 
	| <PROGRAMA: "Programa" >  
	| <IF: "if" > 
	| <ELSE:"else" > 
	| <ELSEIF:"else if" > 
	| <FOR:"for" > 
	| <SWITCH:"switch" > 
	| <CASE:"case" > 
	| <BREAK:"break" > 
	| <DEFAUL:"ipredef" > 
	| <DO:"do" > 
	| <WHILE:"while" > 
	| <WRITE:"write" > 
	| <READ:"read" > //25
}

TOKEN:
{
      <LPAREN: "(" > 
	| <RPAREN: ")" > 
	| <LBRACE: "{" > 
	| <RBRACE: "}" > 
	| <LBRACKET: "[" > 
	| <RBRACKET: "]" > 
	| <SEMICOLON: ";" > 
	| <COMMA: "," > 
	| <DOT: "." > 
	| <DOUBLECOMMA: "\""> //35
}

TOKEN:
{
	  <EQ: "==" > 
	| <LE: "<=" > 
	| <MN: "<" > 
	| <GE: ">=" > 
	| <GR: ">" > 
	| <NE: "!=" > 
	| <OR: "||" > 
	| <AND: "&&"> /43
}

TOKEN:
{
	  <INT:"int"> //44
	| <DEC: "double"> //45
	| <CHR: "char"> //46
	| <STR: "string"> //47
	| <NUMBER : (["0"-"9"])+>  //48
	| <IDENTIFIER : ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9","_"])*>  //49
	| <DECIMAL : (["0"-"9"])+["."](["0"-"9"])+ > //50
	| <CADENA : <DOUBLECOMMA>["a"-"z","A"-"Z","0"-"9"," "](["a"-"z","A"-"Z","0"-"9"," ",":",";","."])*<DOUBLECOMMA>> //51
	| <CARAC : "'"["a"-"z","A"-"Z","0"-"9"]"'" >//52 
	| <DOUBLEPOINT : ":">
}

SKIP : 
{ 
	" "|"\n" | "\r" | "\r\n" | "\t"
}

void MetodoInicioPrograma():
{}
{
	<PROGRAMA><IDENTIFIER><LBRACE>MetodoBloque()<RBRACE><EOF>
}

void MetodoBloque():
{}
{
	LOOKAHEAD(2)MetodoVariablesGlobales() | MetodoPrincipal()
}

void MetodoVariablesGlobales():
{}
{
	(<PRIVATE>|<PUBLIC>)(<INT>|<DEC>|<STR>|<CHR>) <IDENTIFIER>(<COMMA><IDENTIFIER>)* <SEMICOLON> MetodoBloque()
}

void Principal():
{
	TablaDeSimbolos.InicializaListaCompatibilidad();	
}
{
	<MAIN>
	<LBRACE>MetodoSentencias()<RBRACE> 	
}

void MetodoVariablesLocales():
{
	int tipoDeDato;
	Token tok;
}
{
	(
		(MetodoTiposDatos())
		{
			tok = token.kind;
		}
		tok = <IDENTIFIER>
		{
			TablaDeSimbolos.InsertarSimbolo(tok, tipoDeDato);
		}
		[MetodoVariablesAsignacion(tok)]
		(
			<COMMA>
			tok = <IDENTIFIER>
			{
				TablaDeSimbolos.InsertarSimbolo(tok, tipoDeDato);
			}
			[MetodoVariablesAsignacion(tok)]
		)*
		<SEMICOLON>
	)
	(MetodoVariablesSentencias())
}

void MetodoVariablesAsignacion(Token tok1):
{
	Token tok2;
	Token tok3;
	String resultado;
	boolean imp = false;
}
{
	<ASIGNACION>
	(MetodoTiposAsignacion())
	{
		tok2 = token;
		resultado = TablaDeSimbolos.RevisaAsignacion(tok1, tok2);

		if(res != " ") {
			System.out.println(resultado);
			imp = true;
		}
	}
	(MetodoOperacionAritmetica()
		MetodoTiposAsignacion()
		{
			tok3 = token;
			resultado = TablaDeSimbolos.RevisaAsignacion(tok1, tok3);

			if(resultado != " " && !imp) {
				System.out.println(resultado);
			}
		}
	)*
}

void MetodoVariablesSentencias():
{}
{
	LOOKAHEAD(3)MetodoVariablesLocales() | MetodoSentencias()
}

void MetodoSentencias():
{}
{
	(
		  MetodoVariablesLocales()
		| MetodoSentenciaIf()
		| MetodoSentenciaFor()
		| MetodoSentenciaDo()
		| MetodoSentenciaWhile()
		| LOOKAHEAD(2)MetodoSentenciaAsignacion(<SEMICOLON>{ TablaDeSimbolos.segunda = 0;})
		| MetodoSentenciaWrite()
		| MetodoSentenciaRead()<SEMICOLON>
		| MetodoSentenciaSwitch()
	)*
}

void MetodoSentenciaIf():
{}
{
	<IF><LPAREN> MetodoCondicion() <RPAREN><LBRACE> MetodoSentencias() <RBRACE> (void MetodoElse())*
}

void MetodoElse():
{}
{
	<ELSE><LBRACE> MetodoSentencias() <RBRACE> | <ELSEIF><LPAREN> MetodoCondicion() <RPAREN><LBRACE> MetodoSentencias() <RBRACE>
}

void MetodoCondicion():
{}
{
	MetodoComparaciones() ([(<AND> | <OR>)] MetodoComparaciones())*
}

void MetodoComparaciones():
{}
{
	MetodoValor() MetodoOperadores() MetodoValor()
}

void MetodoValor():
{}
{
	LOOKAHEAD(2)(<IDENTIFIER> | <NUMBER>) | MetodoExpresion()
}

void MetodoExpresion():
{}
{
	LOOKAHEAD(2)(<NUMBER> | <IDENTIFIER>) | (<IDENTIFIER> | <NUMBER>) MetodoOperacionAritmetica() (<IDENTIFIER> | <NUMBER>)
}

void MetodoOperadores():
{}
{
	    <EQ> 
	  | <LE> 
	  | <GE> 
	  | <NE> 
	  | <GR> 
	  | <MN> 
}

int MetodoOperacionAritmetica():
{}
{
	  ( <PLUS>  { return 1; } )
	| ( <MINUS> { return 1; } )
	| ( <MULTIPLY> { return 1; } )
	| ( <DIVIDE> { return 1; } )
	| ( { return 0; } )
	
	{ return 0; }
}

void MetodoTiposDatos():
{}
{
	  <INT>
	| <DEC>
	| <STR>
	| <CHR>
}

void MetodoSentenciaFor():
{}
{
	<FOR><LPAREN> (MetodoDeclaraVariableFor() | MetodoSentenciaAsignacion()) <SEMICOLON> MetodoComparaciones() <SEMICOLON> MetodoSentenciaAsignacion() <RPAREN><LBRACE> MetodoSentencias() <RBRACE>
}

void MetodoDeclaraVariableFor():
{
	int tipoDato;
	Token tok;
}
{
	(MetodoTiposDatos())
	{
		tipoDato = token.kind;
	}
	tok = <IDENTIFIER>
	{
		TablaDeSimbolos.InsertarSimbolo(tok, tipoDato);
	}
	[MetodoVariablesAsignacion(tok)]
}

void MetodoSentenciaDo():
{}
{
	<DO><LBRACE> MetodoSentencias() <RBRACE><WHILE><LPAREN> MetodoComparaciones() <RPAREN><SEMICOLON>
}

void MetodoSentenciaWhile():
{
	<WHILE><LPAREN> MetodoComparaciones() <RPAREN><LBRACE> MetodoSentencias() <RBRACE>
}

void MetodoSentenciaAsignacion():
{
	Token tok1;
	Token tok2;
	Token tok3;
	int aux;
	String resultado;
	boolean imp = false;
}
{
	tok1 = <IDENTIFIER>
	(
		<ASIGNACION> (MetodoTiposAsignacion())
		{
			tok2 = token;
			resultado = TablaDeSimbolos.RevisaAsignacion(tok1, tok2);

			if(res != " ") {
				System.out.println(resultado);
				imp = true;
			}
		}
		(
			LOOKAHEAD(2) MetodoOperacionAritmetica()MetodoTiposAsignacion()
			{
				tok3 = token;
				resultado = TablaDeSimbolos.RevisaAsignacion(tok1, tok3);

				if(res != " " && !imp) {
					System.out.println(resultado);
				}
			}
		)*
		|
		(<INCR> | <DECR>)
		{
			resultado = TablaDeSimbolos.RevisaAsignacion(tok1);

			if(res != " ") {
				System.out.println(resultado);
			}
		}
	)
}

void MetodoTiposAsignacion():
{}
{
	  <IDENTIFIER> 
	| <NUMBER> 
	| <DECIMAL> 
	| <CADENA> 
	| <CARAC>	
}

void MetodoSentenciaWrite():
{}
{
	<WRITE><LPAREN> (MetodoExpresion() (<PLUS><CADENA>)* | <CADENA>(<PLUS> MetodoExpresion())*)* <RPAREN><SEMICOLON>
}

void MetodoSentenciaRead():
{}
{
	<READ><LPAREN><RPAREN>
}

void MetodoSentenciaSwitch():
{}
{
	<SWITCH><LPAREN><IDENTIFIER><RPAREN><LBRACE>(<CASE>(<IDENTIFIER> | <CADENA> | <CARAC> | <NUMBER> | <DECIMAL>)<DOUBLEPOINT> (MetodoSentenciaAsignacion()<SEMICOLON>)+ <BREAK><SEMICOLON>)+ [<DEFAUL><DOUBLEPOINT> (MetodoSentenciaAsignacion()<SEMICOLON>)<BREAK><SEMICOLON>] <RBRACE>
}